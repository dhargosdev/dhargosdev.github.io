<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Simulador Brazo Rob√≥tico - 3¬∫ ESO</title>
    <!-- Tailwind CSS para dise√±o moderno -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Three.js para gr√°ficos 3D -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <!-- OrbitControls para mover la c√°mara -->
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    <!-- Google Fonts -->
    <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700&family=Roboto:wght@300;400;500&display=swap" rel="stylesheet">

    <style>
        body {
            margin: 0;
            overflow: hidden;
            font-family: 'Roboto', sans-serif;
            background-color: #f0f4f8;
            color: #334155;
        }
        
        /* Estilo futurista para los t√≠tulos */
        h1, h2, .tech-font {
            font-family: 'Orbitron', sans-serif;
        }

        /* Panel de cristal esmerilado */
        .glass-panel {
            background: rgba(255, 255, 255, 0.75);
            backdrop-filter: blur(12px);
            -webkit-backdrop-filter: blur(12px);
            border: 1px solid rgba(255, 255, 255, 0.9);
            box-shadow: 0 8px 32px 0 rgba(31, 38, 135, 0.1);
        }

        /* Inputs tipo slider personalizados */
        input[type=range] {
            -webkit-appearance: none;
            width: 100%;
            background: transparent;
        }
        input[type=range]::-webkit-slider-thumb {
            -webkit-appearance: none;
            height: 16px;
            width: 16px;
            border-radius: 50%;
            background: #06b6d4; /* Cyan-500 */
            cursor: pointer;
            margin-top: -6px;
            box-shadow: 0 0 10px rgba(6, 182, 212, 0.5);
        }
        input[type=range]::-webkit-slider-runnable-track {
            width: 100%;
            height: 4px;
            cursor: pointer;
            background: #cbd5e1;
            border-radius: 2px;
        }

        /* Animaci√≥n suave para notificaciones */
        @keyframes slideIn {
            from { transform: translateX(100%); opacity: 0; }
            to { transform: translateX(0); opacity: 1; }
        }
        .notification {
            animation: slideIn 0.5s ease-out;
        }
        
        #canvas-container {
            width: 100vw;
            height: 100vh;
            position: absolute;
            top: 0;
            left: 0;
            z-index: 0;
        }
    </style>
</head>
<body>

    <!-- Contenedor 3D -->
    <div id="canvas-container"></div>

    <!-- UI: Panel de Control -->
    <div class="absolute top-0 left-0 h-full w-80 p-6 z-10 flex flex-col pointer-events-none">
        <div class="glass-panel rounded-2xl p-6 pointer-events-auto overflow-y-auto max-h-full shadow-xl border-l-4 border-cyan-500">
            <h1 class="text-2xl font-bold text-slate-800 mb-1">ROBO-ARM <span class="text-cyan-500">MK3</span></h1>
            <p class="text-xs text-slate-500 mb-6 uppercase tracking-wider">Simulador Did√°ctico de Grados de Libertad</p>

            <!-- Secci√≥n de Informaci√≥n Did√°ctica -->
            <div class="bg-blue-50 border border-blue-100 rounded-lg p-3 mb-6">
                <h3 class="font-bold text-blue-800 text-sm mb-1 flex items-center">
                    <svg class="w-4 h-4 mr-1" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M13 16h-1v-4h-1m1-4h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z"></path></svg>
                    Misi√≥n
                </h3>
                <p class="text-xs text-blue-700">
                    Mueve las articulaciones para tocar la <strong>Esfera de Energ√≠a</strong>. Observa c√≥mo cada eje a√±ade un grado de libertad al movimiento.
                </p>
            </div>

            <!-- Controles -->
            <div class="space-y-5">
                
                <!-- Base -->
                <div>
                    <label class="flex justify-between text-sm font-medium text-slate-700 mb-1">
                        <span>Base (Eje Y)</span>
                        <span id="val-base" class="text-cyan-600 font-mono">0¬∞</span>
                    </label>
                    <input type="range" id="slider-base" min="-180" max="180" value="0" step="1">
                </div>

                <!-- Hombro -->
                <div>
                    <label class="flex justify-between text-sm font-medium text-slate-700 mb-1">
                        <span>Hombro (Eje Z)</span>
                        <span id="val-shoulder" class="text-cyan-600 font-mono">0¬∞</span>
                    </label>
                    <input type="range" id="slider-shoulder" min="-45" max="90" value="0" step="1">
                </div>

                <!-- Codo -->
                <div>
                    <label class="flex justify-between text-sm font-medium text-slate-700 mb-1">
                        <span>Codo (Eje Z)</span>
                        <span id="val-elbow" class="text-cyan-600 font-mono">0¬∞</span>
                    </label>
                    <input type="range" id="slider-elbow" min="-90" max="90" value="0" step="1">
                </div>

                <!-- Mu√±eca Vertical -->
                <div>
                    <label class="flex justify-between text-sm font-medium text-slate-700 mb-1">
                        <span>Mu√±eca Pitch (Eje Z)</span>
                        <span id="val-wrist-pitch" class="text-cyan-600 font-mono">0¬∞</span>
                    </label>
                    <input type="range" id="slider-wrist-pitch" min="-90" max="90" value="0" step="1">
                </div>

                 <!-- Mu√±eca Rotaci√≥n -->
                 <div>
                    <label class="flex justify-between text-sm font-medium text-slate-700 mb-1">
                        <span>Mu√±eca Roll (Eje Y)</span>
                        <span id="val-wrist-roll" class="text-cyan-600 font-mono">0¬∞</span>
                    </label>
                    <input type="range" id="slider-wrist-roll" min="-180" max="180" value="0" step="1">
                </div>

                <!-- Pinza -->
                <div class="pt-2 border-t border-slate-200">
                    <label class="flex justify-between text-sm font-medium text-slate-700 mb-1">
                        <span>Apertura Pinza</span>
                        <span id="val-claw" class="text-cyan-600 font-mono">50%</span>
                    </label>
                    <input type="range" id="slider-claw" min="0" max="100" value="50" step="1">
                </div>
            </div>

            <!-- Bot√≥n Reset -->
            <button onclick="resetRobot()" class="mt-8 w-full py-2 bg-slate-200 hover:bg-slate-300 text-slate-700 font-bold rounded-lg transition-colors text-sm uppercase tracking-wide">
                Reiniciar Posici√≥n
            </button>
        </div>
    </div>

    <!-- UI: Notificaciones / Estado -->
    <div class="absolute top-6 right-6 z-10 flex flex-col items-end space-y-4 pointer-events-none">
        <div class="glass-panel px-6 py-3 rounded-full flex items-center space-x-3 shadow-lg">
            <div class="w-3 h-3 bg-green-500 rounded-full animate-pulse"></div>
            <span class="text-sm font-bold text-slate-600">SISTEMA ONLINE</span>
        </div>
        
        <div id="success-msg" class="hidden glass-panel px-6 py-4 rounded-xl border-l-4 border-green-500 shadow-xl notification bg-white/90">
            <h4 class="text-green-600 font-bold text-lg tech-font">¬°OBJETIVO ALCANZADO!</h4>
            <p class="text-slate-600 text-sm">Has demostrado dominio de los grados de libertad.</p>
        </div>
    </div>
    
    <!-- UI: Footer controles de c√°mara -->
    <div class="absolute bottom-6 left-0 w-full text-center pointer-events-none">
        <p class="text-slate-400 text-xs bg-white/80 inline-block px-4 py-1 rounded-full backdrop-blur-sm">
            üñ±Ô∏è Click izq: Rotar c√°mara | üñ±Ô∏è Click der: Mover c√°mara | üñ±Ô∏è Rueda: Zoom
        </p>
    </div>

    <script>
        // Variables Globales Three.js
        let scene, camera, renderer, controls;
        
        // Partes del Robot (Grupos para jerarqu√≠a)
        let robotBase, shoulderJoint, armJoint, elbowJoint, forearmJoint, wristPitchJoint, wristRollJoint, clawBase;
        let clawLeft, clawRight;
        let targetObject; // El objeto a tocar

        // Estado del objetivo
        let objectiveReached = false;

        // Configuraci√≥n de materiales
        const materialWhite = new THREE.MeshStandardMaterial({ 
            color: 0xffffff, 
            roughness: 0.3, 
            metalness: 0.1 
        });
        
        const materialGrey = new THREE.MeshStandardMaterial({ 
            color: 0x94a3b8, 
            roughness: 0.7, 
            metalness: 0.2 
        });

        const materialJoint = new THREE.MeshStandardMaterial({ 
            color: 0x334155, 
            roughness: 0.5, 
            metalness: 0.5
        });

        const materialGlow = new THREE.MeshStandardMaterial({
            color: 0x06b6d4,
            emissive: 0x06b6d4,
            emissiveIntensity: 0.5
        });

        const materialTarget = new THREE.MeshPhongMaterial({
            color: 0xf59e0b, // Amber
            emissive: 0xf59e0b,
            emissiveIntensity: 0.2,
            shininess: 100,
            transparent: true,
            opacity: 0.9
        });

        function init() {
            // 1. Escena
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0xf0f4f8);
            scene.fog = new THREE.Fog(0xf0f4f8, 10, 50);

            // 2. C√°mara
            camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(10, 8, 10);

            // 3. Renderizador
            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            document.getElementById('canvas-container').appendChild(renderer.domElement);

            // 4. Luces
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
            scene.add(ambientLight);

            const dirLight = new THREE.DirectionalLight(0xffffff, 0.8);
            dirLight.position.set(5, 10, 7);
            dirLight.castShadow = true;
            dirLight.shadow.mapSize.width = 1024;
            dirLight.shadow.mapSize.height = 1024;
            scene.add(dirLight);

            // Luz de acento azulada (futurista)
            const spotLight = new THREE.SpotLight(0x06b6d4, 0.5);
            spotLight.position.set(-5, 5, -5);
            spotLight.lookAt(0, 0, 0);
            scene.add(spotLight);

            // 5. Suelo (Grid)
            const gridHelper = new THREE.GridHelper(20, 20, 0xcbd5e1, 0xe2e8f0);
            scene.add(gridHelper);
            
            const planeGeometry = new THREE.PlaneGeometry(20, 20);
            const planeMaterial = new THREE.MeshStandardMaterial({ color: 0xffffff, roughness: 1, metalness: 0 });
            const plane = new THREE.Mesh(planeGeometry, planeMaterial);
            plane.rotation.x = -Math.PI / 2;
            plane.position.y = -0.01;
            plane.receiveShadow = true;
            scene.add(plane);

            // 6. Construir Robot
            buildRobot();

            // 7. Objetivo (Target)
            createTarget();

            // 8. Controles de C√°mara
            controls = new THREE.OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.dampingFactor = 0.05;
            controls.maxPolarAngle = Math.PI / 2 - 0.05; // No dejar que baje del suelo

            // Event Listeners
            window.addEventListener('resize', onWindowResize, false);
            setupUIListeners();

            // Loop de animaci√≥n
            animate();
        }

        function buildRobot() {
            // --- GRUPO BASE (Eje Y) ---
            robotBase = new THREE.Group();
            scene.add(robotBase);

            // Geometr√≠a Base Est√°tica (Pedestal)
            const pedestalGeo = new THREE.CylinderGeometry(1, 1.2, 0.5, 32);
            const pedestal = new THREE.Mesh(pedestalGeo, materialGrey);
            pedestal.position.y = 0.25;
            pedestal.castShadow = true;
            pedestal.receiveShadow = true;
            scene.add(pedestal);

            // Base Rotatoria
            const rotBaseGeo = new THREE.CylinderGeometry(0.8, 0.8, 0.5, 32);
            const rotBase = new THREE.Mesh(rotBaseGeo, materialWhite);
            rotBase.position.y = 0.25; // Relativo al grupo robotBase (que rota)
            rotBase.castShadow = true;
            
            // Junta visual
            addJointDeco(robotBase, 0.6);

            robotBase.position.y = 0.5; // Encima del pedestal
            robotBase.add(rotBase);

            // --- HOMBRO (Shoulder) - Eje Z ---
            // El grupo shoulderJoint rota en Z.
            shoulderJoint = new THREE.Group();
            shoulderJoint.position.y = 0.5; // Altura desde la base
            robotBase.add(shoulderJoint);

            // Mesh del Hombro
            const shoulderGeo = new THREE.BoxGeometry(1, 1, 1);
            const shoulderMesh = new THREE.Mesh(shoulderGeo, materialGrey);
            shoulderMesh.position.y = 0.5;
            shoulderMesh.castShadow = true;
            shoulderJoint.add(shoulderMesh);
            addAxisDeco(shoulderJoint, 0.5, 'z');

            // --- BRAZO (Arm) ---
            // Conectado al hombro
            armJoint = new THREE.Group();
            armJoint.position.y = 1; // Tope del hombro
            shoulderJoint.add(armJoint);

            const armLength = 2.5;
            const armGeo = new THREE.BoxGeometry(0.6, armLength, 0.6);
            const armMesh = new THREE.Mesh(armGeo, materialWhite);
            // IMPORTANTE: Movemos la geometr√≠a para que el pivote est√© en la base del brazo, no en el centro
            armMesh.position.y = armLength / 2; 
            armMesh.castShadow = true;
            armJoint.add(armMesh);
            
            // Decoraci√≥n estilo "sci-fi"
            const armStripe = new THREE.Mesh(new THREE.BoxGeometry(0.65, 0.2, 0.65), materialGlow);
            armStripe.position.y = armLength / 2;
            armJoint.add(armStripe);

            // --- CODO (Elbow) - Eje Z ---
            elbowJoint = new THREE.Group();
            elbowJoint.position.y = armLength; // Al final del brazo
            armJoint.add(elbowJoint);

            // Junta Codo Visual
            const elbowGeo = new THREE.CylinderGeometry(0.5, 0.5, 0.8, 32);
            const elbowMesh = new THREE.Mesh(elbowGeo, materialJoint);
            elbowMesh.rotation.x = Math.PI / 2; // Cilindro horizontal
            elbowMesh.castShadow = true;
            elbowJoint.add(elbowMesh);
            addAxisDeco(elbowJoint, 0, 'z');

            // --- ANTEBRAZO (Forearm) ---
            forearmJoint = new THREE.Group();
            elbowJoint.add(forearmJoint);

            const forearmLength = 2;
            const forearmGeo = new THREE.BoxGeometry(0.5, forearmLength, 0.5);
            const forearmMesh = new THREE.Mesh(forearmGeo, materialWhite);
            forearmMesh.position.y = forearmLength / 2;
            forearmMesh.castShadow = true;
            forearmJoint.add(forearmMesh);

            // --- MU√ëECA PITCH (Arriba/Abajo) - Eje Z ---
            wristPitchJoint = new THREE.Group();
            wristPitchJoint.position.y = forearmLength;
            forearmJoint.add(wristPitchJoint);

            const wristGeo = new THREE.SphereGeometry(0.4, 32, 32);
            const wristMesh = new THREE.Mesh(wristGeo, materialJoint);
            wristMesh.castShadow = true;
            wristPitchJoint.add(wristMesh);

            // --- MU√ëECA ROLL (Rotaci√≥n) - Eje Y ---
            wristRollJoint = new THREE.Group();
            wristPitchJoint.add(wristRollJoint);

            // Base de la pinza
            clawBase = new THREE.Mesh(new THREE.CylinderGeometry(0.2, 0.4, 0.5, 16), materialGrey);
            clawBase.rotation.z = Math.PI / 2; // Orientar hacia adelante si fuera X, pero mantenemos vertical Y
            // Ajustamos para que la pinza apunte hacia "adelante" o "arriba" seg√∫n convenga. 
            // Vamos a hacer que el brazo apunte al cielo por defecto, as√≠ que la pinza sale hacia arriba.
            clawBase.position.y = 0.4;
            clawBase.castShadow = true;
            wristRollJoint.add(clawBase);

            // --- PINZAS (Claw) ---
            // Izquierda
            const clawGeo = new THREE.BoxGeometry(0.1, 0.8, 0.2);
            
            // Grupo para rotar la pinza izq
            clawLeft = new THREE.Group();
            clawLeft.position.y = 0.6; 
            clawLeft.position.x = -0.15;
            wristRollJoint.add(clawLeft);
            
            const clawLMesh = new THREE.Mesh(clawGeo, materialWhite);
            clawLMesh.position.y = 0.3; // Pivote en base
            clawLMesh.rotation.z = 0.2; // Angulo inicial
            clawLeft.add(clawLMesh);

            // Derecha
            clawRight = new THREE.Group();
            clawRight.position.y = 0.6;
            clawRight.position.x = 0.15;
            wristRollJoint.add(clawRight);

            const clawRMesh = new THREE.Mesh(clawGeo, materialWhite);
            clawRMesh.position.y = 0.3;
            clawRMesh.rotation.z = -0.2;
            clawRight.add(clawRMesh);
        }

        function createTarget() {
            const geometry = new THREE.IcosahedronGeometry(0.5, 0);
            targetObject = new THREE.Mesh(geometry, materialTarget);
            
            // Posici√≥n aleatoria alcanzable
            targetObject.position.set(2, 2.5, 2);
            
            targetObject.castShadow = true;
            scene.add(targetObject);

            // Animaci√≥n flotante del target
            targetObject.userData = { offset: Math.random() * 100 };
        }

        // Helpers visuales para entender los ejes
        function addJointDeco(parent, radius) {
            const ring = new THREE.Mesh(
                new THREE.TorusGeometry(radius, 0.05, 16, 100),
                materialGlow
            );
            ring.rotation.x = Math.PI / 2;
            parent.add(ring);
        }

        function addAxisDeco(parent, yPos, axis) {
            // Peque√±o indicador del eje de rotaci√≥n
            const length = 1.5;
            const hex = axis === 'z' ? 0x3b82f6 : 0x06b6d4; // Blue or Cyan
            const dir = axis === 'z' ? new THREE.Vector3(0, 0, 1) : new THREE.Vector3(0, 1, 0);
            // Nota: ArrowHelper es simple pero efectivo
        }

        function setupUIListeners() {
            // Mapping de inputs a rotaciones
            // 1. Base (Y)
            document.getElementById('slider-base').addEventListener('input', (e) => {
                const deg = parseFloat(e.target.value);
                document.getElementById('val-base').innerText = deg + '¬∞';
                robotBase.rotation.y = THREE.MathUtils.degToRad(-deg); // Invertir para sensaci√≥n natural
            });

            // 2. Hombro (Z)
            document.getElementById('slider-shoulder').addEventListener('input', (e) => {
                const deg = parseFloat(e.target.value);
                document.getElementById('val-shoulder').innerText = deg + '¬∞';
                shoulderJoint.rotation.z = THREE.MathUtils.degToRad(deg);
            });

            // 3. Codo (Z)
            document.getElementById('slider-elbow').addEventListener('input', (e) => {
                const deg = parseFloat(e.target.value);
                document.getElementById('val-elbow').innerText = deg + '¬∞';
                elbowJoint.rotation.z = THREE.MathUtils.degToRad(deg);
            });

            // 4. Mu√±eca Pitch (Z)
            document.getElementById('slider-wrist-pitch').addEventListener('input', (e) => {
                const deg = parseFloat(e.target.value);
                document.getElementById('val-wrist-pitch').innerText = deg + '¬∞';
                wristPitchJoint.rotation.z = THREE.MathUtils.degToRad(deg);
            });

            // 5. Mu√±eca Roll (Y)
            document.getElementById('slider-wrist-roll').addEventListener('input', (e) => {
                const deg = parseFloat(e.target.value);
                document.getElementById('val-wrist-roll').innerText = deg + '¬∞';
                wristRollJoint.rotation.y = THREE.MathUtils.degToRad(deg);
            });

            // 6. Pinza (Apertura)
            document.getElementById('slider-claw').addEventListener('input', (e) => {
                const val = parseFloat(e.target.value);
                document.getElementById('val-claw').innerText = val + '%';
                // Mapear 0-100 a √°ngulos
                // 0% abierto = rotaci√≥n original
                // 100% cerrado = rotaci√≥n hacia adentro
                const angle = THREE.MathUtils.mapLinear(val, 0, 100, 0, 0.4);
                clawLeft.rotation.z = -angle;
                clawRight.rotation.z = angle;
            });
        }

        function resetRobot() {
            const sliders = document.querySelectorAll('input[type=range]');
            sliders.forEach(s => {
                s.value = s.defaultValue;
                s.dispatchEvent(new Event('input'));
            });
            objectiveReached = false;
            document.getElementById('success-msg').classList.add('hidden');
            if(targetObject) targetObject.material.color.setHex(0xf59e0b);
            
            // Mover target a otro sitio
            targetObject.position.set(
                (Math.random() > 0.5 ? 1 : -1) * (1.5 + Math.random() * 2),
                1 + Math.random() * 2.5,
                (Math.random() > 0.5 ? 1 : -1) * (1.5 + Math.random() * 2)
            );
        }

        // L√≥gica simple de colisi√≥n / √©xito
        function checkObjective() {
            if (objectiveReached) return;

            // Obtener posici√≥n absoluta de la pinza (usamos clawBase)
            const clawPos = new THREE.Vector3();
            clawBase.getWorldPosition(clawPos);

            const distance = clawPos.distanceTo(targetObject.position);
            
            // Umbral de distancia para considerar que lo toca
            if (distance < 0.8) {
                objectiveReached = true;
                targetObject.material.color.setHex(0x22c55e); // Green
                document.getElementById('success-msg').classList.remove('hidden');
            }
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function animate() {
            requestAnimationFrame(animate);

            // Animaci√≥n target (flotar y rotar)
            if (targetObject) {
                const time = Date.now() * 0.002;
                targetObject.rotation.x += 0.01;
                targetObject.rotation.y += 0.01;
                targetObject.position.y += Math.sin(time + targetObject.userData.offset) * 0.003;
            }

            checkObjective();
            controls.update();
            renderer.render(scene, camera);
        }

        // Iniciar app
        init();

    </script>
</body>
</html>
