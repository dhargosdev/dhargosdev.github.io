<!doctype html>
<html lang="es">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Simulador DOF ‚Äî Brazo Rob√≥tico 3D (3¬∫ ESO)</title>
  <style>
    :root{
      --bg1:#f6fbff;
      --bg2:#eef6ff;
      --card: rgba(255,255,255,.72);
      --card2: rgba(255,255,255,.55);
      --ink:#0b1220;
      --muted:#3b4a66;
      --accent:#2ea4ff;
      --accent2:#7c5cff;
      --ok:#18c37e;
      --warn:#ffb020;
      --shadow: 0 18px 50px rgba(17,38,82,.14);
      --radius: 18px;
      --mono: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
      --sans: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Arial, "Noto Sans", "Helvetica Neue", sans-serif;
    }

    *{box-sizing:border-box}
    body{
      margin:0;
      font-family:var(--sans);
      color:var(--ink);
      background:
        radial-gradient(1200px 900px at 20% 10%, rgba(46,164,255,.18), transparent 55%),
        radial-gradient(900px 700px at 80% 20%, rgba(124,92,255,.16), transparent 52%),
        radial-gradient(800px 700px at 65% 80%, rgba(24,195,126,.10), transparent 55%),
        linear-gradient(180deg, var(--bg1), var(--bg2));
      min-height:100vh;
      overflow-x:hidden;
    }

    header{
      padding:28px 20px 14px;
      max-width:1250px;
      margin:0 auto;
      display:flex;
      gap:16px;
      align-items:flex-end;
      justify-content:space-between;
    }
    .title{
      display:flex; gap:14px; align-items:center;
    }
    .badge{
      width:44px; height:44px; border-radius:14px;
      background: linear-gradient(135deg, rgba(46,164,255,.95), rgba(124,92,255,.95));
      box-shadow: var(--shadow);
      position:relative;
    }
    .badge:before{
      content:"";
      position:absolute; inset:10px;
      border-radius:10px;
      border:2px solid rgba(255,255,255,.85);
      filter: drop-shadow(0 8px 18px rgba(0,0,0,.12));
    }
    h1{
      font-size: clamp(18px, 2.4vw, 26px);
      margin:0;
      letter-spacing:.2px;
    }
    .subtitle{
      margin:6px 0 0;
      color:var(--muted);
      font-size:14px;
      max-width:62ch;
    }

    .topControls{
      display:flex; gap:10px; flex-wrap:wrap; align-items:center;
      justify-content:flex-end;
    }

    .pill{
      background: rgba(255,255,255,.7);
      border: 1px solid rgba(120,140,180,.25);
      padding:10px 12px;
      border-radius: 999px;
      box-shadow: 0 10px 30px rgba(17,38,82,.08);
      backdrop-filter: blur(10px);
      display:flex; gap:10px; align-items:center;
      font-size:13px;
    }
    .pill select, .pill button{
      font-size:13px;
      border-radius: 999px;
      border:1px solid rgba(120,140,180,.35);
      background: rgba(255,255,255,.9);
      padding:7px 10px;
      cursor:pointer;
    }
    .pill button{
      background: linear-gradient(135deg, rgba(46,164,255,.18), rgba(124,92,255,.14));
      border:1px solid rgba(46,164,255,.28);
    }
    .pill button:hover{ filter:brightness(1.03) }

    main{
      max-width:1250px;
      margin:0 auto;
      padding: 10px 20px 26px;
      display:grid;
      grid-template-columns: 1.6fr 1fr;
      gap:16px;
    }

    .panel{
      background: var(--card);
      border: 1px solid rgba(120,140,180,.24);
      border-radius: var(--radius);
      box-shadow: var(--shadow);
      backdrop-filter: blur(14px);
      overflow:hidden;
    }

    .viewer{
      position:relative;
      min-height: 520px;
    }
    #canvasWrap{
      position:absolute; inset:0;
    }
    .viewerHeader{
      position:absolute;
      left:14px; top:14px;
      right:14px;
      display:flex; gap:10px; align-items:center; justify-content:space-between;
      pointer-events:none;
    }
    .hud{
      pointer-events:none;
      display:flex; gap:10px; flex-wrap:wrap;
    }
    .chip{
      pointer-events:none;
      font-family: var(--mono);
      font-size:12px;
      padding:8px 10px;
      border-radius: 999px;
      background: rgba(255,255,255,.78);
      border: 1px solid rgba(120,140,180,.22);
      box-shadow: 0 10px 22px rgba(17,38,82,.09);
    }
    .chip strong{ color: var(--accent2) }

    .note{
      position:absolute;
      right:14px; bottom:14px;
      max-width: 380px;
      background: rgba(255,255,255,.72);
      border: 1px solid rgba(120,140,180,.22);
      border-radius: 14px;
      padding:10px 12px;
      color: var(--muted);
      font-size: 13px;
      box-shadow: 0 16px 36px rgba(17,38,82,.11);
    }

    .controls{
      padding:14px;
    }
    .controls h2{
      margin:0 0 8px;
      font-size:16px;
    }
    .controls .hint{
      color: var(--muted);
      font-size:13px;
      margin:0 0 12px;
    }

    .grid{
      display:grid;
      grid-template-columns: 1fr;
      gap:10px;
    }

    .sliderRow{
      background: var(--card2);
      border:1px solid rgba(120,140,180,.20);
      border-radius: 14px;
      padding:10px 10px 9px;
      display:grid;
      grid-template-columns: 1fr auto;
      gap:8px 10px;
      align-items:center;
    }

    .labelLine{
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:10px;
    }
    .labelLine .name{
      font-weight:650;
      font-size:13px;
      letter-spacing:.2px;
      display:flex; align-items:center; gap:8px;
    }
    .dot{
      width:10px; height:10px; border-radius:999px;
      background: linear-gradient(135deg, var(--accent), var(--accent2));
      box-shadow: 0 6px 14px rgba(46,164,255,.22);
    }
    .value{
      font-family: var(--mono);
      font-size:12px;
      color: var(--muted);
      opacity:.95;
    }

    input[type="range"]{
      width:100%;
      accent-color: var(--accent);
    }

    .toggle{
      display:flex; align-items:center; gap:10px;
      padding:10px;
      background: rgba(255,255,255,.62);
      border:1px solid rgba(120,140,180,.22);
      border-radius: 14px;
      margin-top:10px;
    }
    .toggle input{ transform: scale(1.1); }

    .lesson{
      padding:14px 14px 16px;
      border-top: 1px solid rgba(120,140,180,.18);
    }
    .lesson h3{
      margin:0 0 8px;
      font-size:15px;
    }
    .lesson p{
      margin:0 0 8px;
      color: var(--muted);
      font-size:13px;
      line-height:1.45;
    }
    .callout{
      background: rgba(46,164,255,.10);
      border: 1px solid rgba(46,164,255,.18);
      border-radius: 14px;
      padding:10px 12px;
      font-size:13px;
      color: var(--muted);
      margin-top:10px;
    }
    .callout b{ color: var(--ink) }

    .twoCols{
      display:grid;
      grid-template-columns: 1fr 1fr;
      gap:10px;
      margin-top:10px;
    }
    .mini{
      background: rgba(255,255,255,.62);
      border:1px solid rgba(120,140,180,.20);
      border-radius: 14px;
      padding:10px 12px;
      color: var(--muted);
      font-size:13px;
    }
    .mini strong{ color: var(--ink) }
    .mini .k{
      display:inline-block;
      font-family: var(--mono);
      background: rgba(124,92,255,.10);
      border:1px solid rgba(124,92,255,.18);
      padding:2px 6px;
      border-radius: 999px;
      margin-right:6px;
      color: var(--ink);
    }

    footer{
      max-width:1250px;
      margin:0 auto;
      padding: 0 20px 22px;
      color: rgba(59,74,102,.85);
      font-size: 12.5px;
    }
    a{ color: var(--accent2); text-decoration:none }
    a:hover{ text-decoration:underline }

    @media (max-width: 980px){
      main{ grid-template-columns: 1fr; }
      .viewer{ min-height: 480px; }
      .twoCols{ grid-template-columns: 1fr; }
      header{ align-items:flex-start; flex-direction:column; }
      .topControls{ justify-content:flex-start; }
    }
  </style>
</head>
<body>
  <header>
    <div class="title">
      <div class="badge" aria-hidden="true"></div>
      <div>
        <h1>Simulador de grados de libertad (DOF) ‚Äî Brazo rob√≥tico 3D</h1>
        <p class="subtitle">
          Mueve articulaciones, activa/desactiva ejes y descubre cu√°ntos <b>grados de libertad</b> tiene el brazo.
          Ideal para 3¬∫ ESO: <b>prueba ‚Üí observa ‚Üí explica</b>.
        </p>
      </div>
    </div>

    <div class="topControls">
      <div class="pill">
        <span style="font-weight:650;">Config DOF</span>
        <select id="dofPreset" title="Elige una configuraci√≥n t√≠pica de robot">
          <option value="2">2 DOF (plano: hombro + codo)</option>
          <option value="3">3 DOF (+ giro de base)</option>
          <option value="4">4 DOF (+ mu√±eca pitch)</option>
          <option value="5">5 DOF (+ mu√±eca yaw)</option>
          <option value="6" selected>6 DOF (+ rotaci√≥n herramienta)</option>
        </select>
      </div>

      <div class="pill">
        <button id="btnReset" type="button">‚Ü∫ Reset</button>
        <button id="btnRandom" type="button">üé≤ Postura aleatoria</button>
      </div>
    </div>
  </header>

  <main>
    <!-- VISOR 3D -->
    <section class="panel viewer" aria-label="Visor 3D del brazo rob√≥tico">
      <div class="viewerHeader">
        <div class="hud">
          <div class="chip">DOF activos: <strong id="dofCount">6</strong></div>
          <div class="chip">Posici√≥n herramienta: <strong id="eePos">‚Äî</strong></div>
          <div class="chip">Orientaci√≥n: <strong id="eeOri">‚Äî</strong></div>
        </div>
      </div>

      <div id="canvasWrap"></div>

      <div class="note">
        üí° <b>Idea clave:</b> un DOF es un ‚Äúmovimiento independiente‚Äù.  
        Si desactivas un eje (por ejemplo, la mu√±eca), el robot pierde libertad para orientar la herramienta.
      </div>
    </section>

    <!-- CONTROLES + DID√ÅCTICA -->
    <section class="panel" aria-label="Controles y explicaci√≥n did√°ctica">
      <div class="controls">
        <h2>Controles de articulaciones</h2>
        <p class="hint">Desliza para mover. Activa ‚ÄúMostrar ejes‚Äù para ver el sentido de giro.</p>

        <div class="grid" id="sliders"></div>

        <div class="toggle">
          <input id="showAxes" type="checkbox" checked />
          <label for="showAxes"><b>Mostrar ejes</b> (X/Y/Z) y referencia</label>
        </div>

        <div class="toggle">
          <input id="showGhost" type="checkbox" checked />
          <label for="showGhost"><b>Mostrar postura ‚Äúfantasma‚Äù</b> al cambiar DOF (comparaci√≥n)</label>
        </div>
      </div>

      <div class="lesson">
        <h3>Mini-lecci√≥n r√°pida</h3>
        <p>
          En rob√≥tica educativa solemos separar:
          <b>posicionar</b> (llegar a un punto del espacio) y <b>orientar</b> (girar la herramienta).
          Un brazo t√≠pico industrial usa <b>6 DOF</b>: 3 para posici√≥n + 3 para orientaci√≥n.
        </p>

        <div class="twoCols">
          <div class="mini">
            <div><span class="k">DOF</span><strong>¬øQu√© es?</strong></div>
            <div style="margin-top:6px">
              Un movimiento independiente: giro o desplazamiento que puedes cambiar sin ‚Äúobligar‚Äù a otro.
            </div>
          </div>
          <div class="mini">
            <div><span class="k">Reto</span><strong>Investiga</strong></div>
            <div style="margin-top:6px">
              ¬øPuedes llegar al mismo punto con diferentes posturas? Eso se llama <b>redundancia</b>.
            </div>
          </div>
        </div>

        <div class="callout" id="didacticText">
          <b>Actividad sugerida:</b> Selecciona <b>3 DOF</b>. Intenta apuntar la pinza hacia abajo sin mover el punto final.
          ¬øQu√© ocurre? Explica por qu√© faltan DOF.
        </div>
      </div>
    </section>
  </main>

  <footer>
    Hecho para uso did√°ctico. Funciona offline salvo la carga de Three.js por CDN.
    Si quieres, te lo adapto para que vaya <b>100% offline</b> (incluyendo librer√≠a embebida) o para a√±adir ‚Äúmisiones‚Äù evaluables.
  </footer>

  <!-- Three.js -->
  <script src="https://unpkg.com/three@0.160.0/build/three.min.js"></script>

  <script>
    // ============
    // Utilidades UI
    // ============
    const clamp = (v, a, b) => Math.min(b, Math.max(a, v));
    const deg2rad = d => d * Math.PI / 180;
    const rad2deg = r => r * 180 / Math.PI;
    const fmt = n => (Math.round(n * 10) / 10).toFixed(1);

    // ================
    // Config articulaciones
    // ================
    // Estructura: cada "joint" es una rotaci√≥n en un eje local (aprox did√°ctica).
    const joints = [
      { id:"baseYaw",   name:"Base (Yaw)",       axis:"Y", min:-180, max:180, value:  0, enabled:true,  color:"#2ea4ff", tip:"Giro sobre el eje vertical (como una peonza)." },
      { id:"shoulder",  name:"Hombro (Pitch)",   axis:"Z", min:-60,  max:120, value: 35, enabled:true,  color:"#7c5cff", tip:"Sube/baja el brazo principal." },
      { id:"elbow",     name:"Codo (Pitch)",     axis:"Z", min:-10,  max:150, value: 70, enabled:true,  color:"#18c37e", tip:"Dobla el antebrazo." },
      { id:"wristPitch",name:"Mu√±eca (Pitch)",   axis:"Z", min:-120, max:120, value: 15, enabled:true,  color:"#ffb020", tip:"Ajusta inclinaci√≥n de la herramienta." },
      { id:"wristYaw",  name:"Mu√±eca (Yaw)",     axis:"Y", min:-180, max:180, value: 20, enabled:true,  color:"#ff6b9b", tip:"Gira lateralmente la herramienta." },
      { id:"toolRoll",  name:"Herramienta (Roll)",axis:"X",min:-180, max:180, value: 10, enabled:true,  color:"#3bd3ff", tip:"Gira la herramienta sobre su propio eje." }
    ];

    // Presets t√≠picos (2..6 DOF)
    // 2 DOF: hombro + codo (plano)
    // 3 DOF: + baseYaw
    // 4 DOF: + wristPitch
    // 5 DOF: + wristYaw
    // 6 DOF: + toolRoll
    const presetMap = {
      2: ["shoulder","elbow"],
      3: ["baseYaw","shoulder","elbow"],
      4: ["baseYaw","shoulder","elbow","wristPitch"],
      5: ["baseYaw","shoulder","elbow","wristPitch","wristYaw"],
      6: ["baseYaw","shoulder","elbow","wristPitch","wristYaw","toolRoll"]
    };

    // ==================
    // Escena Three.js
    // ==================
    const wrap = document.getElementById("canvasWrap");
    const scene = new THREE.Scene();
    scene.fog = new THREE.Fog(0xf6fbff, 6, 26);

    const camera = new THREE.PerspectiveCamera(45, 1, 0.1, 100);
    camera.position.set(7.5, 5.2, 8.2);
    camera.lookAt(0, 2.2, 0);

    const renderer = new THREE.WebGLRenderer({ antialias:true, alpha:true });
    renderer.setPixelRatio(Math.min(devicePixelRatio, 2));
    wrap.appendChild(renderer.domElement);

    // Luces suaves, estilo "lab"
    const hemi = new THREE.HemisphereLight(0xffffff, 0xbfd8ff, 0.95);
    scene.add(hemi);

    const key = new THREE.DirectionalLight(0xffffff, 0.9);
    key.position.set(6, 10, 4);
    key.castShadow = false;
    scene.add(key);

    const fill = new THREE.DirectionalLight(0xffffff, 0.35);
    fill.position.set(-7, 6, -3);
    scene.add(fill);

    // Rejilla
    const grid = new THREE.GridHelper(18, 36, 0xbfd0ff, 0xdde9ff);
    grid.position.y = 0;
    grid.material.opacity = 0.35;
    grid.material.transparent = true;
    scene.add(grid);

    // Base "pedestal"
    const pedestalMat = new THREE.MeshStandardMaterial({
      color: 0xffffff,
      metalness: 0.25,
      roughness: 0.35
    });
    const pedestal = new THREE.Mesh(new THREE.CylinderGeometry(1.1, 1.25, 0.55, 32), pedestalMat);
    pedestal.position.y = 0.275;
    scene.add(pedestal);

    const ring = new THREE.Mesh(new THREE.TorusGeometry(0.95, 0.08, 16, 64), new THREE.MeshStandardMaterial({
      color: 0xbfd8ff,
      metalness: 0.35,
      roughness: 0.25,
      transparent: true,
      opacity: 0.7
    }));
    ring.rotation.x = Math.PI / 2;
    ring.position.y = 0.56;
    scene.add(ring);

    // Grupo principal del brazo
    const armRoot = new THREE.Group();
    armRoot.position.y = 0.56;
    scene.add(armRoot);

    // Material "futurista claro"
    const armMat = new THREE.MeshStandardMaterial({
      color: 0xffffff,
      metalness: 0.38,
      roughness: 0.28
    });
    const accentMat = new THREE.MeshStandardMaterial({
      color: 0xe7f3ff,
      metalness: 0.22,
      roughness: 0.18
    });

    // Funci√≥n para pieza tipo c√°psula
    function capsule(len, r){
      const g = new THREE.CapsuleGeometry(r, Math.max(0.01, len - 2*r), 10, 18);
      const m = new THREE.Mesh(g, armMat);
      return m;
    }

    // Jerarqu√≠a:
    // armRoot -> baseYawGroup -> shoulderGroup -> upperArm -> elbowGroup -> foreArm -> wristGroup -> toolGroup -> gripper
    const baseYawGroup = new THREE.Group();
    armRoot.add(baseYawGroup);

    // Columna base
    const column = capsule(1.4, 0.22);
    column.position.y = 0.7;
    baseYawGroup.add(column);

    const shoulderGroup = new THREE.Group();
    shoulderGroup.position.y = 1.35;
    baseYawGroup.add(shoulderGroup);

    const shoulderHub = new THREE.Mesh(new THREE.SphereGeometry(0.28, 22, 22), accentMat);
    shoulderGroup.add(shoulderHub);

    const upperArm = capsule(2.1, 0.18);
    upperArm.position.y = 1.05;
    upperArm.rotation.x = Math.PI/2; // orientar a lo largo del eje local Y (visual)
    // Ajuste: giramos para que visualmente apunte "hacia adelante" cuando pitch cambia en Z
    upperArm.rotation.z = Math.PI/2;
    shoulderGroup.add(upperArm);

    const elbowGroup = new THREE.Group();
    elbowGroup.position.y = 2.1;
    shoulderGroup.add(elbowGroup);

    const elbowHub = new THREE.Mesh(new THREE.SphereGeometry(0.24, 22, 22), accentMat);
    elbowGroup.add(elbowHub);

    const foreArm = capsule(1.7, 0.16);
    foreArm.position.y = 0.85;
    foreArm.rotation.z = Math.PI/2;
    elbowGroup.add(foreArm);

    const wristGroup = new THREE.Group();
    wristGroup.position.y = 1.7;
    elbowGroup.add(wristGroup);

    const wristHub = new THREE.Mesh(new THREE.SphereGeometry(0.20, 20, 20), accentMat);
    wristGroup.add(wristHub);

    const toolGroup = new THREE.Group();
    toolGroup.position.y = 0.35;
    wristGroup.add(toolGroup);

    const toolBody = capsule(0.9, 0.12);
    toolBody.position.y = 0.45;
    toolBody.rotation.z = Math.PI/2;
    toolGroup.add(toolBody);

    // Pinza simple
    const gripper = new THREE.Group();
    gripper.position.y = 0.95;
    toolGroup.add(gripper);

    const fingerGeo = new THREE.BoxGeometry(0.10, 0.35, 0.14);
    const fingerMat = new THREE.MeshStandardMaterial({
      color: 0xf2f7ff, metalness: 0.25, roughness: 0.22
    });

    const leftFinger = new THREE.Mesh(fingerGeo, fingerMat);
    const rightFinger = new THREE.Mesh(fingerGeo, fingerMat);
    leftFinger.position.set(0.14, 0.10, 0);
    rightFinger.position.set(-0.14, 0.10, 0);
    gripper.add(leftFinger, rightFinger);

    // Ejes
    const axesRoot = new THREE.AxesHelper(2.4);
    axesRoot.material.transparent = true;
    axesRoot.material.opacity = 0.9;
    scene.add(axesRoot);

    const eeAxes = new THREE.AxesHelper(0.9);
    toolGroup.add(eeAxes);

    // Fantasma (postura anterior)
    const ghost = new THREE.Group();
    scene.add(ghost);

    function cloneAsGhost(originalGroup){
      ghost.clear();
      const c = originalGroup.clone(true);
      // Material "fantasma"
      c.traverse(obj=>{
        if(obj.isMesh){
          obj.material = obj.material.clone();
          obj.material.transparent = true;
          obj.material.opacity = 0.18;
        }
      });
      ghost.add(c);
    }

    // ==================
    // Controles de c√°mara (drag sin librer√≠as)
    // ==================
    let dragging=false;
    let lastX=0, lastY=0;
    let yaw=0.78, pitch=0.42; // √°ngulos c√°mara
    let radius=12.0;

    function updateCamera(){
      pitch = clamp(pitch, -0.05, 1.25);
      const x = radius * Math.cos(pitch) * Math.cos(yaw);
      const z = radius * Math.cos(pitch) * Math.sin(yaw);
      const y = radius * Math.sin(pitch) + 2.2;
      camera.position.set(x, y, z);
      camera.lookAt(0, 2.2, 0);
    }
    updateCamera();

    renderer.domElement.addEventListener("pointerdown", (e)=>{
      dragging=true;
      lastX=e.clientX; lastY=e.clientY;
      renderer.domElement.setPointerCapture(e.pointerId);
    });
    renderer.domElement.addEventListener("pointermove", (e)=>{
      if(!dragging) return;
      const dx = e.clientX - lastX;
      const dy = e.clientY - lastY;
      lastX=e.clientX; lastY=e.clientY;
      yaw -= dx * 0.006;
      pitch -= dy * 0.006;
      updateCamera();
    });
    renderer.domElement.addEventListener("pointerup", ()=>{
      dragging=false;
    });
    renderer.domElement.addEventListener("wheel", (e)=>{
      radius = clamp(radius + e.deltaY * 0.01, 7.2, 22);
      updateCamera();
    }, {passive:true});

    // ==================
    // L√≥gica: aplicar articulaciones
    // ==================
    const jointToGroup = {
      baseYaw: baseYawGroup,
      shoulder: shoulderGroup,
      elbow: elbowGroup,
      wristPitch: wristGroup,
      wristYaw: wristGroup,
      toolRoll: toolGroup
    };

    function applyJoints(){
      // Reset rotaciones (para no acumular)
      baseYawGroup.rotation.set(0,0,0);
      shoulderGroup.rotation.set(0,0,0);
      elbowGroup.rotation.set(0,0,0);
      wristGroup.rotation.set(0,0,0);
      toolGroup.rotation.set(0,0,0);

      // Aplicar en orden:
      // baseYaw (Y)
      const jBase = joints.find(j=>j.id==="baseYaw");
      if(jBase.enabled) baseYawGroup.rotation.y = deg2rad(jBase.value);

      // shoulder (Z)
      const jSh = joints.find(j=>j.id==="shoulder");
      if(jSh.enabled) shoulderGroup.rotation.z = deg2rad(jSh.value);

      // elbow (Z)
      const jEl = joints.find(j=>j.id==="elbow");
      if(jEl.enabled) elbowGroup.rotation.z = deg2rad(jEl.value);

      // wrist pitch (Z)
      const jWp = joints.find(j=>j.id==="wristPitch");
      if(jWp.enabled) wristGroup.rotation.z = deg2rad(jWp.value);

      // wrist yaw (Y) (se suma a la mu√±eca)
      const jWy = joints.find(j=>j.id==="wristYaw");
      if(jWy.enabled) wristGroup.rotation.y = deg2rad(jWy.value);

      // tool roll (X)
      const jTr = joints.find(j=>j.id==="toolRoll");
      if(jTr.enabled) toolGroup.rotation.x = deg2rad(jTr.value);

      // Actualizar HUD end effector (posici√≥n y orientaci√≥n aproximadas)
      toolGroup.updateWorldMatrix(true,true);

      const p = new THREE.Vector3();
      const q = new THREE.Quaternion();
      toolGroup.getWorldPosition(p);
      toolGroup.getWorldQuaternion(q);

      // Convertimos quaternion a euler para leerlo f√°cil (en grados)
      const eul = new THREE.Euler().setFromQuaternion(q, "XYZ");
      document.getElementById("eePos").textContent = `${fmt(p.x)}, ${fmt(p.y)}, ${fmt(p.z)}`;
      document.getElementById("eeOri").textContent = `X ${fmt(rad2deg(eul.x))}¬∞ ¬∑ Y ${fmt(rad2deg(eul.y))}¬∞ ¬∑ Z ${fmt(rad2deg(eul.z))}¬∞`;

      // DOF activos = articulaciones habilitadas
      const dof = joints.filter(j=>j.enabled).length;
      document.getElementById("dofCount").textContent = dof.toString();

      // Mostrar/ocultar ejes
      const showAxes = document.getElementById("showAxes").checked;
      axesRoot.visible = showAxes;
      eeAxes.visible = showAxes;

      // Texto did√°ctico contextual
      updateDidacticText(dof);
    }

    // ==========
    // UI sliders
    // ==========
    const slidersDiv = document.getElementById("sliders");

    function makeSlider(j){
      const row = document.createElement("div");
      row.className = "sliderRow";
      row.dataset.id = j.id;

      const left = document.createElement("div");
      const labelLine = document.createElement("div");
      labelLine.className = "labelLine";

      const name = document.createElement("div");
      name.className = "name";
      const dot = document.createElement("span");
      dot.className = "dot";
      dot.style.background = `linear-gradient(135deg, ${j.color}, rgba(124,92,255,.85))`;
      name.appendChild(dot);
      name.appendChild(document.createTextNode(j.name));

      const value = document.createElement("div");
      value.className = "value";
      value.id = `val_${j.id}`;
      value.textContent = `${j.value}¬∞`;

      labelLine.appendChild(name);
      labelLine.appendChild(value);

      const tip = document.createElement("div");
      tip.className = "value";
      tip.style.opacity = 0.85;
      tip.textContent = `Eje ${j.axis} ¬∑ ${j.tip}`;

      left.appendChild(labelLine);
      left.appendChild(tip);

      const right = document.createElement("div");
      right.style.display="grid";
      right.style.justifyItems="end";
      right.style.gap="8px";

      const chk = document.createElement("input");
      chk.type="checkbox";
      chk.checked = j.enabled;
      chk.title = "Activar/Desactivar este DOF";

      const rng = document.createElement("input");
      rng.type="range";
      rng.min = j.min;
      rng.max = j.max;
      rng.value = j.value;
      rng.step = 1;

      function syncEnabled(){
        rng.disabled = !chk.checked;
        row.style.opacity = chk.checked ? "1" : "0.55";
        j.enabled = chk.checked;
        applyJoints();
      }

      chk.addEventListener("change", syncEnabled);
      rng.addEventListener("input", ()=>{
        j.value = parseInt(rng.value, 10);
        document.getElementById(`val_${j.id}`).textContent = `${j.value}¬∞`;
        applyJoints();
      });

      right.appendChild(chk);

      // Range ocupa toda la fila -> lo ponemos debajo (CSS ya lo hace por grid principal)
      row.appendChild(left);
      row.appendChild(right);

      // range debajo
      const rangeWrap = document.createElement("div");
      rangeWrap.style.gridColumn = "1 / -1";
      rangeWrap.appendChild(rng);
      row.appendChild(rangeWrap);

      // init
      syncEnabled();
      return row;
    }

    function renderSliders(){
      slidersDiv.innerHTML = "";
      joints.forEach(j=>slidersDiv.appendChild(makeSlider(j)));
    }

    // =======================
    // Presets + acciones
    // =======================
    const presetSelect = document.getElementById("dofPreset");
    const btnReset = document.getElementById("btnReset");
    const btnRandom = document.getElementById("btnRandom");

    function setPreset(dof){
      const enabledIds = new Set(presetMap[dof] || presetMap[6]);

      // Guardar fantasma si est√° activado
      if(document.getElementById("showGhost").checked){
        cloneAsGhost(scene); // clona toda la escena, pero nos interesa sobre todo el brazo
        // Mejor: clonar solo el root del brazo y pedestal para comparar
        ghost.clear();
        const armClone = armRoot.clone(true);
        armClone.traverse(obj=>{
          if(obj.isMesh){
            obj.material = obj.material.clone();
            obj.material.transparent = true;
            obj.material.opacity = 0.18;
          }
        });
        ghost.add(armClone);
      }else{
        ghost.clear();
      }

      joints.forEach(j=>{
        j.enabled = enabledIds.has(j.id);
      });

      // Ajustes recomendados por preset
      if(dof === 2){
        joints.find(j=>j.id==="baseYaw").value = 0;
        joints.find(j=>j.id==="wristPitch").value = 0;
        joints.find(j=>j.id==="wristYaw").value = 0;
        joints.find(j=>j.id==="toolRoll").value = 0;
      }

      renderSliders();
      applyJoints();
    }

    function resetPose(){
      const defaults = { baseYaw:0, shoulder:35, elbow:70, wristPitch:15, wristYaw:20, toolRoll:10 };
      joints.forEach(j=> j.value = defaults[j.id] ?? 0 );
      renderSliders();
      applyJoints();
    }

    function randomPose(){
      joints.forEach(j=>{
        j.value = Math.round(j.min + Math.random()*(j.max-j.min));
      });
      renderSliders();
      applyJoints();
    }

    presetSelect.addEventListener("change", ()=>{
      setPreset(parseInt(presetSelect.value, 10));
    });
    btnReset.addEventListener("click", resetPose);
    btnRandom.addEventListener("click", randomPose);

    document.getElementById("showAxes").addEventListener("change", applyJoints);
    document.getElementById("showGhost").addEventListener("change", ()=>{
      // al cambiar, si se desactiva quitamos
      if(!document.getElementById("showGhost").checked) ghost.clear();
    });

    function updateDidacticText(dof){
      const el = document.getElementById("didacticText");
      let text = "";
      if(dof <= 2){
        text = `<b>Actividad:</b> Con <b>2 DOF</b>, el movimiento es casi ‚Äúplano‚Äù. 
                ¬øPuedes mover la pinza a izquierda/derecha sin girar la base? ¬øPor qu√© no?`;
      }else if(dof === 3){
        text = `<b>Actividad:</b> Con <b>3 DOF</b> ya puedes ‚Äúbarrer‚Äù el espacio con la base.
                Intenta mantener el punto final fijo mientras cambias <b>base</b>. ¬øQu√© articulaci√≥n compensa?`;
      }else if(dof === 4){
        text = `<b>Actividad:</b> Con <b>4 DOF</b> puedes mejorar la <b>orientaci√≥n</b> un poco.
                ¬øLogras apuntar la pinza hacia abajo en diferentes posiciones? ¬øD√≥nde falla?`;
      }else if(dof === 5){
        text = `<b>Actividad:</b> Con <b>5 DOF</b> casi puedes orientar la herramienta, pero puede faltar un giro.
                Busca una postura donde te ‚Äúfalte‚Äù rotaci√≥n para alinear bien la pinza.`;
      }else{
        text = `<b>Actividad:</b> Con <b>6 DOF</b> puedes controlar <b>posici√≥n + orientaci√≥n</b>.
                Reto: intenta llegar a un punto y luego gira solo la herramienta (<b>roll</b>) sin cambiar la posici√≥n.`;
      }
      el.innerHTML = text;
    }

    // ==================
    // Resize + render loop
    // ==================
    function resize(){
      const w = wrap.clientWidth;
      const h = wrap.clientHeight;
      renderer.setSize(w, h, false);
      camera.aspect = w / h;
      camera.updateProjectionMatrix();
    }
    window.addEventListener("resize", resize);

    // Animaci√≥n sutil (respiraci√≥n de luz)
    let t0 = performance.now();
    function animate(t){
      const dt = (t - t0) * 0.001;
      t0 = t;

      ring.rotation.z += dt * 0.3;
      ring.material.opacity = 0.62 + 0.08 * Math.sin(t*0.0012);

      renderer.render(scene, camera);
      requestAnimationFrame(animate);
    }

    // Init
    renderSliders();
    resize();
    setPreset(6);
    applyJoints();
    requestAnimationFrame(animate);
  </script>
</body>
</html>
