<!doctype html>
<html lang="es">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Simulador de Ecosistema (50√ó50)</title>
  <style>
    :root{
      --bg:#0b1220;
      --panel:#111a2b;
      --panel2:#0e1727;
      --text:#e7eefc;
      --muted:#a9b6d6;
      --accent:#28d17c;
      --danger:#ff6b6b;
      --cell:16px;
      --gap:1px;
      --radius:16px;
      --shadow: 0 14px 40px rgba(0,0,0,.35);
      --mono: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
      --sans: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "Apple Color Emoji", "Segoe UI Emoji";
    }

    *{ box-sizing:border-box; }

    body{
      margin:0;
      font-family: var(--sans);
      color:var(--text);
      background: radial-gradient(1200px 600px at 20% 10%, rgba(40,209,124,.18), transparent 60%),
                  radial-gradient(1200px 600px at 80% 20%, rgba(89,134,255,.16), transparent 60%),
                  var(--bg);
      min-height:100vh;
    }

    header{
      padding:16px 20px;
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:12px;
      border-bottom:1px solid rgba(255,255,255,.06);
      background: linear-gradient(180deg, rgba(255,255,255,.04), transparent);
    }

    header .title{
      display:flex;
      flex-direction:column;
      gap:2px;
    }

    header h1{
      margin:0;
      font-size:16px;
      letter-spacing:.2px;
      font-weight:750;
    }

    header .sub{
      color:var(--muted);
      font-size:12px;
    }

    .wrap{
      display:flex;
      gap:14px;
      padding:14px;
      max-width: 1400px;
      margin: 0 auto;
    }

    .worldPanel{
      flex: 1 1 auto;
      min-width: 560px;
      background: linear-gradient(180deg, rgba(255,255,255,.06), rgba(255,255,255,.02));
      border:1px solid rgba(255,255,255,.08);
      border-radius: var(--radius);
      box-shadow: var(--shadow);
      overflow:hidden;
    }

    .worldTop{
      display:flex;
      align-items:center;
      justify-content:space-between;
      padding:10px 12px;
      background: rgba(0,0,0,.18);
      border-bottom:1px solid rgba(255,255,255,.06);
    }

    .badge{
      display:inline-flex;
      align-items:center;
      gap:8px;
      padding:7px 10px;
      border-radius: 999px;
      background: rgba(40,209,124,.12);
      border:1px solid rgba(40,209,124,.25);
      color: #dffbed;
      font-size:12px;
      font-family: var(--mono);
      white-space: nowrap;
    }

    .gridWrap{
      padding:10px;
      background: rgba(0,0,0,.10);
    }

    .grid{
      display:grid;
      grid-template-columns: repeat(50, var(--cell));
      grid-template-rows: repeat(50, var(--cell));
      gap: var(--gap);
      justify-content:center;
      width: fit-content;
      margin: 0 auto;
      padding: 10px;
      border-radius: 14px;
      background: rgba(255,255,255,.03);
      border: 1px solid rgba(255,255,255,.06);
    }

    .cell{
      width: var(--cell);
      height: var(--cell);
      display:flex;
      align-items:center;
      justify-content:center;
      font-size: calc(var(--cell) * 0.85);
      line-height: 1;
      user-select:none;
      border-radius: 4px;
      background: rgba(10,16,28,.35);
    }

    .cell[data-t="plant"]{ background: rgba(40,209,124,.10); }
    .cell[data-t="herb"]{ background: rgba(102,163,255,.10); }
    .cell[data-t="carn"]{ background: rgba(255,107,107,.10); }
    .cell[data-t="omni"]{ background: rgba(255,209,102,.10); }

    .side{
      width: 440px;
      flex: 0 0 440px;
      display:flex;
      flex-direction:column;
      gap:14px;
    }

    .card{
      background: linear-gradient(180deg, rgba(255,255,255,.06), rgba(255,255,255,.02));
      border:1px solid rgba(255,255,255,.08);
      border-radius: var(--radius);
      box-shadow: var(--shadow);
      overflow:hidden;
    }

    .card .hd{
      padding: 10px 12px;
      background: rgba(0,0,0,.18);
      border-bottom:1px solid rgba(255,255,255,.06);
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:12px;
    }

    .card .hd h2{
      margin:0;
      font-size:13px;
      font-weight:750;
      letter-spacing:.2px;
    }

    .card .bd{
      padding: 12px;
    }

    .row{
      display:flex;
      gap:10px;
      flex-wrap:wrap;
      align-items:flex-end;
    }

    .btn{
      appearance:none;
      border:1px solid rgba(255,255,255,.12);
      background: rgba(255,255,255,.06);
      color: var(--text);
      padding:9px 10px;
      border-radius: 12px;
      font-weight:700;
      cursor:pointer;
      transition: transform .05s ease, background .15s ease, border-color .15s ease;
    }

    .btn:hover{ background: rgba(255,255,255,.09); border-color: rgba(255,255,255,.18); }
    .btn:active{ transform: translateY(1px); }

    .btn.primary{
      background: rgba(40,209,124,.14);
      border-color: rgba(40,209,124,.30);
    }

    .btn.danger{
      background: rgba(255,107,107,.12);
      border-color: rgba(255,107,107,.28);
    }

    .kv{
      display:grid;
      grid-template-columns: 1fr auto;
      gap: 6px 10px;
      font-family: var(--mono);
      font-size: 12px;
      color: var(--muted);
      margin-top: 8px;
    }

    .kv b{ color: var(--text); font-weight: 800; }

    .form{
      display:grid;
      grid-template-columns: 1fr 1fr;
      gap: 10px;
    }

    .field{
      display:flex;
      flex-direction:column;
      gap:6px;
      padding: 10px;
      border-radius: 14px;
      border: 1px solid rgba(255,255,255,.06);
      background: rgba(0,0,0,.12);
    }

    .field label{
      font-size: 11px;
      color: var(--muted);
      letter-spacing: .2px;
    }

    input[type="number"], input[type="range"], select{
      width:100%;
      padding: 8px 10px;
      border-radius: 12px;
      border: 1px solid rgba(255,255,255,.12);
      background: rgba(255,255,255,.06);
      color: var(--text);
      outline:none;
    }

    input[type="range"]{ padding: 10px; }

    .small{
      font-size: 11px;
      color: var(--muted);
      line-height: 1.25;
    }

    canvas{
      display:block;
      width: 100%;
      height: 220px;
      background: rgba(0,0,0,.10);
      border:1px solid rgba(255,255,255,.06);
      border-radius: 14px;
    }

    .legend{
      display:flex;
      gap:10px;
      flex-wrap:wrap;
      margin-top: 8px;
      font-size: 12px;
      color: var(--muted);
    }
    .pill{ padding:6px 10px; border-radius:999px; border:1px solid rgba(255,255,255,.10); background: rgba(255,255,255,.05); }

    .hint{
      margin-top: 10px;
      padding: 10px;
      border-radius: 14px;
      background: rgba(40,209,124,.08);
      border:1px solid rgba(40,209,124,.22);
      color: #dffbed;
      font-size: 12px;
      line-height: 1.35;
    }

    footer{
      padding: 10px 14px 18px;
      color: rgba(231,238,252,.65);
      font-size: 11px;
      text-align:center;
    }

    @media (max-width: 1200px){
      .wrap{ flex-direction:column; }
      .side{ width: 100%; flex: 1 1 auto; }
      .worldPanel{ min-width: unset; }
      .grid{ transform-origin: top center; }
    }
  </style>
</head>
<body>
  <header>
    <div class="title">
      <h1>üåç Simulador de ecosistema (50√ó50)</h1>
      <div class="sub">Pompones üçÄ ¬∑ Bacilones ü¶† ¬∑ Cocos üëª ¬∑ Superquecos ü¶∏üèª ¬∑ 1 individuo por celda</div>
    </div>
    <div class="badge" id="statusBadge">EPOCH 0 ¬∑ detenido</div>
  </header>

  <div class="wrap">
    <section class="worldPanel">
      <div class="worldTop">
        <div class="badge" id="countsBadge">üçÄ 0 ¬∑ ü¶† 0 ¬∑ üëª 0 ¬∑ ü¶∏üèª 0</div>
        <div class="row">
          <label class="small" style="display:flex;align-items:center;gap:10px;">
            Tama√±o celda
            <input id="cellSize" type="range" min="12" max="22" value="16" />
          </label>
        </div>
      </div>
      <div class="gridWrap">
        <div class="grid" id="grid"></div>
      </div>
    </section>

    <aside class="side">
      <section class="card">
        <div class="hd">
          <h2>‚è±Ô∏è Controles</h2>
          <div class="row">
            <button class="btn primary" id="btnStart">‚ñ∂ Iniciar</button>
            <button class="btn" id="btnStep">‚è≠Ô∏è Paso</button>
            <button class="btn danger" id="btnReset">‚Üª Reiniciar</button>
          </div>
        </div>
        <div class="bd">
          <div class="row" style="align-items:center; justify-content:space-between;">
            <div style="flex:1; min-width: 240px;">
              <label class="small" for="speed">Velocidad (√©pocas/seg)</label>
              <input id="speed" type="range" min="1" max="60" value="12" />
            </div>
            <div class="badge" id="speedBadge">12 eps</div>
          </div>

          <div class="kv" id="stats">
            <div>√âpoca</div><b id="stEpoch">0</b>
            <div>Vivos</div><b id="stAlive">0</b>
            <div>Muertes (agotamiento)</div><b id="stDeaths">0</b>
            <div>Reproducciones</div><b id="stBirths">0</b>
            <div>Comidas</div><b id="stEats">0</b>
          </div>

          <div class="hint">
            Reglas clave: para comer, el depredador debe estar <b>hambriento</b> (energ√≠a &lt; ¬Ω de su m√°ximo) y la presa debe estar en una celda contigua. Para reproducirse, dos individuos contiguos de la misma especie con energ√≠a &gt; ¬Ω del m√°ximo, y una celda libre contigua para la cr√≠a.
          </div>
        </div>
      </section>

      <section class="card">
        <div class="hd">
          <h2>‚öôÔ∏è Par√°metros</h2>
          <button class="btn" id="btnApply">Aplicar</button>
        </div>
        <div class="bd">
          <div class="form">
            <div class="field">
              <label>üçÄ Pompones iniciales</label>
              <input type="number" id="initPlants" min="0" max="2500" value="40" />
            </div>
            <div class="field">
              <label>ü¶† Bacilones iniciales</label>
              <input type="number" id="initHerb" min="0" max="2500" value="20" />
            </div>
            <div class="field">
              <label>üëª Cocos iniciales</label>
              <input type="number" id="initCarn" min="0" max="2500" value="10" />
            </div>
            <div class="field">
              <label>ü¶∏üèª Superquecos iniciales</label>
              <input type="number" id="initOmni" min="0" max="2500" value="5" />
            </div>

            <div class="field">
              <label>Energ√≠a m√°xima (animales)</label>
              <input type="number" id="maxEnergy" min="1" max="200" value="20" />
            </div>
            <div class="field">
              <label>Energ√≠a inicial (animales)</label>
              <input type="number" id="startEnergy" min="1" max="200" value="20" />
            </div>

            <div class="field">
              <label>üçÄ Energ√≠a por pomp√≥n</label>
              <input type="number" id="gainPlant" min="1" max="200" value="10" />
            </div>
            <div class="field">
              <label>ü¶† Energ√≠a por bacil√≥n</label>
              <input type="number" id="gainHerb" min="1" max="200" value="14" />
            </div>

            <div class="field">
              <label>üëª Energ√≠a por coco</label>
              <input type="number" id="gainCarn" min="1" max="200" value="16" />
            </div>
            <div class="field">
              <label>Metabolismo (‚àíenerg√≠a/√©poca)</label>
              <input type="number" id="metabolic" min="0" max="10" value="1" />
            </div>

            <div class="field" style="grid-column: 1 / -1;">
              <label>üçÄ Tasa de aparici√≥n de pompones (por √©poca)</label>
              <input type="range" id="plantRate" min="0" max="0.2" step="0.005" value="0.03" />
              <div class="small" id="plantRateLabel">0.030</div>
            </div>

            <div class="field">
              <label>Avanzar (prob.)</label>
              <input type="number" id="pForward" min="0" max="1" step="0.01" value="0.60" />
            </div>
            <div class="field">
              <label>Girar izq. (prob.)</label>
              <input type="number" id="pLeft" min="0" max="1" step="0.01" value="0.20" />
            </div>

            <div class="field">
              <label>Girar dcha. (prob.)</label>
              <input type="number" id="pRight" min="0" max="1" step="0.01" value="0.20" />
            </div>
            <div class="field">
              <label>Borde del mundo</label>
              <select id="edges">
                <option value="wrap" selected>Toroidal (se envuelve)</option>
                <option value="wall">Pared (se bloquea)</option>
              </select>
            </div>

            <div class="field" style="grid-column: 1 / -1;">
              <label>L√≠mite de nuevos üçÄ por √©poca</label>
              <input type="number" id="plantCap" min="0" max="200" value="12" />
              <div class="small">Evita explosiones de poblaci√≥n vegetal si subes mucho la tasa.</div>
            </div>
          </div>

          <div class="small" style="margin-top:10px;">
            Nota: la tasa de aparici√≥n de üçÄ se aplica como un crecimiento dependiente del espacio libre: cuanto m√°s lleno est√° el mundo de pompones, menos aparecen espont√°neamente.
          </div>
        </div>
      </section>

      <section class="card">
        <div class="hd">
          <h2>üìà Evoluci√≥n de la poblaci√≥n</h2>
          <div class="badge" id="historyBadge">historial: 0</div>
        </div>
        <div class="bd">
          <canvas id="chart" width="420" height="220"></canvas>
          <div class="legend">
            <span class="pill">üçÄ Pompones</span>
            <span class="pill">ü¶† Bacilones</span>
            <span class="pill">üëª Cocos</span>
            <span class="pill">ü¶∏üèª Superquecos</span>
          </div>
        </div>
      </section>
    </aside>
  </div>

  <footer>
    Hecho con üíö ¬∑ Ajusta par√°metros y observa c√≥mo cambian las din√°micas: escasez de plantas, depredaci√≥n, omnivor√≠a y reproducci√≥n.
  </footer>

  <script>
    // =========================
    //  Config y utilidades
    // =========================
    const W = 50, H = 50, N = W*H;

    const EMOJI = {
      plant: "üçÄ",
      herb: "ü¶†",
      carn: "üëª",
      omni: "ü¶∏üèª",
    };

    const DIRS = [
      {dx:0, dy:-1}, // 0 up
      {dx:1, dy:0},  // 1 right
      {dx:0, dy:1},  // 2 down
      {dx:-1,dy:0},  // 3 left
    ];

    const $ = (id) => document.getElementById(id);

    function clamp(v, a, b){ return Math.max(a, Math.min(b, v)); }

    function randInt(n){ return Math.floor(Math.random()*n); }

    function shuffle(arr){
      for(let i=arr.length-1;i>0;i--){
        const j = randInt(i+1);
        [arr[i], arr[j]] = [arr[j], arr[i]];
      }
      return arr;
    }

    function idx(x,y){ return y*W + x; }

    function inBounds(x,y){ return x>=0 && x<W && y>=0 && y<H; }

    function movePos(x,y,dir,edges){
      const {dx,dy} = DIRS[dir];
      let nx = x + dx;
      let ny = y + dy;

      if(edges === "wrap"){
        nx = (nx + W) % W;
        ny = (ny + H) % H;
        return {x:nx, y:ny, blocked:false};
      }

      // wall
      if(!inBounds(nx,ny)) return {x, y, blocked:true};
      return {x:nx, y:ny, blocked:false};
    }

    function neighbors4(x,y,edges){
      const out=[];
      for(let d=0; d<4; d++){
        const p = movePos(x,y,d,edges);
        // en modo wall, si est√° bloqueado, el vecino no existe
        if(edges==="wall" && p.blocked) continue;
        out.push({x:p.x,y:p.y,dir:d});
      }
      return out;
    }

    // =========================
    //  Estado del mundo
    // =========================
    let config = null;
    let grid = new Array(N).fill(null); // guarda id de entidad o null
    let entities = new Map();           // id -> entidad
    let nextId = 1;

    let running = false;
    let epoch = 0;
    let timer = null;

    // m√©tricas
    let deaths = 0;
    let births = 0;
    let eats = 0;

    // historial para gr√°fica
    const history = {
      plant: [], herb: [], carn: [], omni: []
    };
    const HISTORY_MAX = 500;

    // celdas DOM
    const cellEls = [];

    function readConfigFromUI(){
      const initPlants = parseInt($("initPlants").value,10) || 0;
      const initHerb   = parseInt($("initHerb").value,10)   || 0;
      const initCarn   = parseInt($("initCarn").value,10)   || 0;
      const initOmni   = parseInt($("initOmni").value,10)   || 0;

      const maxEnergy  = Math.max(1, parseInt($("maxEnergy").value,10) || 20);
      const startEnergy= clamp(parseInt($("startEnergy").value,10) || maxEnergy, 1, 999);

      const gainPlant  = Math.max(1, parseInt($("gainPlant").value,10) || 10);
      const gainHerb   = Math.max(1, parseInt($("gainHerb").value,10)  || 14);
      const gainCarn   = Math.max(1, parseInt($("gainCarn").value,10)  || 16);
      const metabolic  = clamp(parseInt($("metabolic").value,10) || 1, 0, 20);

      const plantRate  = parseFloat($("plantRate").value) || 0;
      const plantCap   = clamp(parseInt($("plantCap").value,10) || 0, 0, 500);

      // movimiento
      let pForward = clamp(parseFloat($("pForward").value) || 0.6, 0, 1);
      let pLeft    = clamp(parseFloat($("pLeft").value)    || 0.2, 0, 1);
      let pRight   = clamp(parseFloat($("pRight").value)   || 0.2, 0, 1);
      // normalizamos si no suma 1
      const s = pForward + pLeft + pRight;
      if(s <= 0.0001){ pForward=0.6; pLeft=0.2; pRight=0.2; }
      else { pForward/=s; pLeft/=s; pRight/=s; }

      const edges = $("edges").value;

      return {
        init: { plant:initPlants, herb:initHerb, carn:initCarn, omni:initOmni },
        maxEnergy,
        startEnergy: clamp(startEnergy, 1, maxEnergy),
        gain: { plant:gainPlant, herb:gainHerb, carn:gainCarn },
        metabolic,
        plantRate,
        plantCap,
        moveProb: { forward:pForward, left:pLeft, right:pRight },
        edges,
      };
    }

    function resetWorld(newConfig){
      config = newConfig;
      grid = new Array(N).fill(null);
      entities = new Map();
      nextId = 1;
      epoch = 0;
      deaths = 0;
      births = 0;
      eats = 0;

      history.plant.length = 0;
      history.herb.length = 0;
      history.carn.length = 0;
      history.omni.length = 0;

      // colocaci√≥n inicial
      seedEntities("plant", config.init.plant, null);
      seedEntities("herb",  config.init.herb,  config.startEnergy);
      seedEntities("carn",  config.init.carn,  config.startEnergy);
      seedEntities("omni",  config.init.omni,  config.startEnergy);

      pushHistory();
      renderAll();
      drawChart();
      updateBadges();
    }

    function randomEmptyCell(maxTries=2000){
      // intento aleatorio; si el mundo est√° lleno, devolvemos null
      for(let t=0;t<maxTries;t++){
        const i = randInt(N);
        if(grid[i] === null){
          return {x: i%W, y: Math.floor(i/W)};
        }
      }
      // fallback: barrido lineal si hay hueco
      for(let i=0;i<N;i++) if(grid[i]===null) return {x:i%W,y:Math.floor(i/W)};
      return null;
    }

    function addEntity(type, x, y, energy=null){
      const i = idx(x,y);
      if(grid[i] !== null) return null;
      const id = nextId++;
      const e = {
        id,
        type,
        x,
        y,
        dir: randInt(4),
        energy,
        reproduced:false,
      };
      entities.set(id, e);
      grid[i] = id;
      return e;
    }

    function removeEntityById(id){
      const e = entities.get(id);
      if(!e) return;
      grid[idx(e.x,e.y)] = null;
      entities.delete(id);
    }

    function moveEntityTo(e, nx, ny){
      const from = idx(e.x,e.y);
      const to   = idx(nx,ny);
      if(grid[to] !== null) return false;
      grid[from] = null;
      grid[to] = e.id;
      e.x = nx;
      e.y = ny;
      return true;
    }

    function seedEntities(type, count, energy){
      for(let k=0;k<count;k++){
        const p = randomEmptyCell();
        if(!p) break;
        addEntity(type, p.x, p.y, (type==="plant"? null : energy));
      }
    }

    function countByType(){
      let c = {plant:0, herb:0, carn:0, omni:0};
      for(const e of entities.values()) c[e.type]++;
      return c;
    }

    function hungry(e){
      if(e.type === "plant") return false;
      return e.energy < (config.maxEnergy / 2);
    }

    // =========================
    //  Din√°mica del ecosistema
    // =========================

    function spawnPlants(){
      const counts = countByType();
      const plants = counts.plant;
      const maxPlants = N;

      // crecimiento dependiente del espacio libre:
      // expected = rate * (espacio libre)
      let expected = config.plantRate * (maxPlants - plants);
      expected = Math.min(expected, config.plantCap);

      let n = Math.floor(expected);
      const frac = expected - n;
      if(Math.random() < frac) n++;

      for(let i=0;i<n;i++){
        const p = randomEmptyCell(400);
        if(!p) break;
        addEntity("plant", p.x, p.y, null);
      }
    }

    function chooseTurnDelta(){
      const r = Math.random();
      const pF = config.moveProb.forward;
      const pL = config.moveProb.left;
      // const pR = config.moveProb.right;
      if(r < pF) return 0;
      if(r < pF + pL) return -1;
      return +1;
    }

    function tryEat(e){
      if(e.type === "plant") return false;
      if(!hungry(e)) return false;

      const neigh = neighbors4(e.x,e.y,config.edges);
      const preyTypes = (e.type === "herb") ? ["plant"] :
                        (e.type === "carn") ? ["herb"]  :
                        (e.type === "omni") ? ["carn","herb","plant"] : [];

      let candidates = [];
      for(const n of neigh){
        const id2 = grid[idx(n.x,n.y)];
        if(id2 === null) continue;
        const v = entities.get(id2);
        if(!v) continue;
        if(preyTypes.includes(v.type)) candidates.push(v);
      }

      if(candidates.length === 0) return false;

      // Preferencias para omn√≠voros: primero carn, luego herb, luego plant.
      if(e.type === "omni"){
        candidates.sort((a,b)=> preyTypes.indexOf(a.type) - preyTypes.indexOf(b.type));
        // pero puede haber varios de la misma categor√≠a: elegimos aleatorio dentro del grupo top
        const bestType = candidates[0].type;
        const best = candidates.filter(v=>v.type===bestType);
        candidates = [ best[randInt(best.length)] ];
      } else {
        candidates = [ candidates[randInt(candidates.length)] ];
      }

      const victim = candidates[0];
      // mover al depredador a la celda de la v√≠ctima y consumir
      const vx=victim.x, vy=victim.y;
      removeEntityById(victim.id);
      // la celda queda libre tras quitar a la v√≠ctima
      const moved = moveEntityTo(e, vx, vy);
      if(!moved){
        // por seguridad (no deber√≠a ocurrir)
        addEntity(victim.type, vx, vy, victim.energy);
        return false;
      }

      const gain = (victim.type === "plant") ? config.gain.plant :
                   (victim.type === "herb")  ? config.gain.herb  :
                   (victim.type === "carn")  ? config.gain.carn  : 0;

      e.energy = clamp(e.energy + gain, 0, config.maxEnergy);
      eats++;
      return true;
    }

    function tryMove(e){
      if(e.type === "plant") return;

      // superquecos solo se mueven si tienen hambre
      if(e.type === "omni" && !hungry(e)) return;

      // Si tienen hambre, primero intentan comer si hay presa contigua.
      if(tryEat(e)) return;

      // Movimiento aleatorio con direcci√≥n persistente
      const delta = chooseTurnDelta();
      e.dir = (e.dir + delta + 4) % 4;

      const p = movePos(e.x, e.y, e.dir, config.edges);
      if(config.edges==="wall" && p.blocked) return;

      const to = idx(p.x,p.y);
      if(grid[to] !== null) return;

      moveEntityTo(e, p.x, p.y);
    }

    function tryReproduction(){
      // reiniciamos marca
      for(const e of entities.values()) e.reproduced = false;

      const all = Array.from(entities.values()).filter(e=>e.type!=="plant");
      shuffle(all);

      for(const e of all){
        if(e.reproduced) continue;
        if(e.energy <= (config.maxEnergy/2)) continue;

        // busca pareja contigua
        const neigh = neighbors4(e.x,e.y,config.edges);
        const mates = [];
        for(const n of neigh){
          const id2 = grid[idx(n.x,n.y)];
          if(id2 === null) continue;
          const m = entities.get(id2);
          if(!m) continue;
          if(m.type !== e.type) continue;
          if(m.reproduced) continue;
          if(m.energy <= (config.maxEnergy/2)) continue;
          mates.push(m);
        }
        if(mates.length === 0) continue;

        const mate = mates[randInt(mates.length)];

        // busca celda libre contigua a cualquiera de los progenitores
        const candidates = [];
        for(const parent of [e, mate]){
          for(const n of neighbors4(parent.x,parent.y,config.edges)){
            if(grid[idx(n.x,n.y)] === null) candidates.push({x:n.x,y:n.y});
          }
        }
        if(candidates.length === 0) continue;

        const spot = candidates[randInt(candidates.length)];

        // consume energ√≠a: 1/4 de la energ√≠a m√°xima
        const cost = config.maxEnergy / 4;
        e.energy = clamp(e.energy - cost, 0, config.maxEnergy);
        mate.energy = clamp(mate.energy - cost, 0, config.maxEnergy);

        addEntity(e.type, spot.x, spot.y, config.maxEnergy/2);
        e.reproduced = true;
        mate.reproduced = true;
        births++;
      }
    }

    function applyMetabolismAndDeaths(){
      const all = Array.from(entities.values()).filter(e=>e.type!=="plant");
      for(const e of all){
        e.energy -= config.metabolic;
        if(e.energy <= 0){
          removeEntityById(e.id);
          deaths++;
        }
      }
    }

    function tick(){
      epoch++;

      // 1) crecimiento vegetal
      spawnPlants();

      // 2) movimientos (y comidas si procede)
      const movers = Array.from(entities.values()).filter(e=>e.type!=="plant");
      shuffle(movers);
      for(const e of movers){
        // podr√≠a haber muerto en esta misma √©poca por otro (depredaci√≥n)
        if(!entities.has(e.id)) continue;
        tryMove(e);
      }

      // 3) reproducci√≥n
      tryReproduction();

      // 4) metabolismo y muertes
      applyMetabolismAndDeaths();

      // 5) m√©tricas e interfaz
      pushHistory();
      renderAll();
      if(epoch % 1 === 0) drawChart();
      updateBadges();
    }

    // =========================
    //  Render
    // =========================
    function buildGrid(){
      const gridEl = $("grid");
      gridEl.innerHTML = "";
      cellEls.length = 0;
      for(let i=0;i<N;i++){
        const c = document.createElement("div");
        c.className = "cell";
        c.textContent = "";
        gridEl.appendChild(c);
        cellEls.push(c);
      }
    }

    function renderAll(){
      // limpiamos
      for(let i=0;i<N;i++){
        const c = cellEls[i];
        c.textContent = "";
        c.removeAttribute("data-t");
      }
      // pintamos
      for(const e of entities.values()){
        const i = idx(e.x,e.y);
        const c = cellEls[i];
        c.textContent = EMOJI[e.type];
        c.setAttribute("data-t", e.type);
        // tooltip suave
        if(e.type === "plant"){
          c.title = "Pomp√≥n üçÄ";
        } else {
          c.title = `${labelType(e.type)} ¬∑ energ√≠a ${Math.round(e.energy)}/${config.maxEnergy}`;
        }
      }

      const counts = countByType();
      $("countsBadge").textContent = `üçÄ ${counts.plant} ¬∑ ü¶† ${counts.herb} ¬∑ üëª ${counts.carn} ¬∑ ü¶∏üèª ${counts.omni}`;

      $("stEpoch").textContent = String(epoch);
      $("stAlive").textContent = String(entities.size);
      $("stDeaths").textContent = String(deaths);
      $("stBirths").textContent = String(births);
      $("stEats").textContent = String(eats);
    }

    function labelType(t){
      return t==="herb"?"Bacil√≥n ü¶†": t==="carn"?"Coco üëª": t==="omni"?"Superqueco ü¶∏üèª":"Pomp√≥n üçÄ";
    }

    function updateBadges(){
      $("statusBadge").textContent = `EPOCH ${epoch} ¬∑ ${running?"en marcha":"detenido"}`;
      const eps = parseInt($("speed").value,10);
      $("speedBadge").textContent = `${eps} eps`;
      $("historyBadge").textContent = `historial: ${history.plant.length}`;
    }

    // =========================
    //  Historial + gr√°fica
    // =========================
    function pushHistory(){
      const c = countByType();
      history.plant.push(c.plant);
      history.herb.push(c.herb);
      history.carn.push(c.carn);
      history.omni.push(c.omni);
      if(history.plant.length > HISTORY_MAX){
        history.plant.shift();
        history.herb.shift();
        history.carn.shift();
        history.omni.shift();
      }
    }

    function drawChart(){
      const canvas = $("chart");
      const ctx = canvas.getContext("2d");
      const w = canvas.width;
      const h = canvas.height;

      ctx.clearRect(0,0,w,h);

      // fondo
      ctx.fillStyle = "rgba(0,0,0,0.10)";
      ctx.fillRect(0,0,w,h);

      const series = [
        {k:"plant", emoji:"üçÄ"},
        {k:"herb",  emoji:"ü¶†"},
        {k:"carn",  emoji:"üëª"},
        {k:"omni",  emoji:"ü¶∏üèª"},
      ];

      const L = history.plant.length;
      if(L < 2) return;

      // rango
      let maxV = 1;
      for(const s of series){
        for(const v of history[s.k]) maxV = Math.max(maxV, v);
      }

      const pad = 12;
      const x0 = pad;
      const y0 = pad;
      const x1 = w - pad;
      const y1 = h - pad;

      // rejilla suave
      ctx.strokeStyle = "rgba(255,255,255,0.08)";
      ctx.lineWidth = 1;
      for(let i=0;i<=4;i++){
        const yy = y0 + (y1-y0) * (i/4);
        ctx.beginPath();
        ctx.moveTo(x0, yy);
        ctx.lineTo(x1, yy);
        ctx.stroke();
      }

      // dibujamos sin fijar colores expl√≠citos (dejamos que el navegador use defaults de strokeStyle?),
      // pero necesitamos distinguirlas: usaremos alpha y dashes, sin especificar colores fuertes.
      // Aun as√≠, definimos colores suaves neutrales por legibilidad.
      const styles = {
        plant: {stroke:"rgba(40,209,124,0.95)", dash:[]},
        herb:  {stroke:"rgba(102,163,255,0.95)", dash:[6,4]},
        carn:  {stroke:"rgba(255,107,107,0.95)", dash:[2,4]},
        omni:  {stroke:"rgba(255,209,102,0.95)", dash:[10,4,2,4]},
      };

      function plot(key){
        const arr = history[key];
        ctx.strokeStyle = styles[key].stroke;
        ctx.setLineDash(styles[key].dash);
        ctx.lineWidth = 2;
        ctx.beginPath();
        for(let i=0;i<L;i++){
          const x = x0 + (x1-x0) * (i/(L-1));
          const y = y1 - (y1-y0) * (arr[i]/maxV);
          if(i===0) ctx.moveTo(x,y);
          else ctx.lineTo(x,y);
        }
        ctx.stroke();
        ctx.setLineDash([]);
      }

      plot("plant");
      plot("herb");
      plot("carn");
      plot("omni");

      // etiquetas m√≠nimas
      ctx.fillStyle = "rgba(231,238,252,0.85)";
      ctx.font = "11px " + getComputedStyle(document.documentElement).getPropertyValue("--mono");
      ctx.fillText("0", x0, y1+10);
      ctx.fillText(String(maxV), x0, y0+10);
    }

    // =========================
    //  Control de ejecuci√≥n
    // =========================

    function start(){
      if(running) return;
      running = true;
      $("btnStart").textContent = "‚è∏ Pausar";
      restartTimer();
      updateBadges();
    }

    function stop(){
      running = false;
      $("btnStart").textContent = "‚ñ∂ Iniciar";
      if(timer){ clearInterval(timer); timer = null; }
      updateBadges();
    }

    function restartTimer(){
      if(timer){ clearInterval(timer); timer = null; }
      if(!running) return;
      const eps = clamp(parseInt($("speed").value,10) || 12, 1, 200);
      const interval = 1000 / eps;
      timer = setInterval(tick, interval);
    }

    // =========================
    //  Eventos UI
    // =========================
    function wireUI(){
      $("btnStart").addEventListener("click", ()=>{
        if(running) stop(); else start();
      });

      $("btnStep").addEventListener("click", ()=>{
        if(running) return;
        tick();
      });

      $("btnReset").addEventListener("click", ()=>{
        stop();
        resetWorld(readConfigFromUI());
      });

      $("btnApply").addEventListener("click", ()=>{
        // aplicar par√°metros reiniciando el mundo para evitar inconsistencias
        stop();
        resetWorld(readConfigFromUI());
      });

      $("speed").addEventListener("input", ()=>{
        updateBadges();
        if(running) restartTimer();
      });

      $("cellSize").addEventListener("input", (ev)=>{
        document.documentElement.style.setProperty("--cell", ev.target.value + "px");
      });

      $("plantRate").addEventListener("input", ()=>{
        $("plantRateLabel").textContent = parseFloat($("plantRate").value).toFixed(3);
      });
    }

    // =========================
    //  Init
    // =========================
    buildGrid();
    wireUI();
    $("plantRateLabel").textContent = parseFloat($("plantRate").value).toFixed(3);
    resetWorld(readConfigFromUI());
  </script>
</body>
</html>
